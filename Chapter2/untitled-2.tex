\chapter{Single Source Shortest Path}

Weights are a great way to convey additional data in a graph. Whether it is representing the distance between two cities, or the cost in seconds to transfer data via a certain path, connected and weighted graphs are a huge help.
However, a new problem arises with the addition of weights: The Single Source Shortest Path Problem.

%Perhaps an example here of a weighted graph, how to easily find the path from node A to F? etc.
\begin{definition}
A \emph{Single Source Shortest Path} is the shortest path from a starting node to any other node in the connected graph.
\end{definition}

A fairly straightforward concept, but one that comes with its own troubles in trying to actually find such a path between any two nodes algorithmically. Below are two solutions to such a problem: Dijkstra's Algorithm and the Bellman-Ford Algorithm.

\section{Dijkstra}
Dijkstra's algorithm starts at some decided source node, and then follows each edge from the source path out to the adjacent nodes. Each node is then given a "cost", which is the sum of all the edges' weights on the path from the source node to that node. 

After finding the cost for each node adjacent to the source node, the algorithm repeats, taking each node adjacent to the source node, and finding the costs of thier adjacent nodes, until all nodes have a cost assigned to them. For example, the cost of a node that is two edges away from the source node would be the sum of the weights of those two edges.

The algorithm does not end there, however. In a connected graph, there is a very real possibility of a cycle existing, which means there is more than one potential path from the source node to all other nodes. In this instance, the algorithm could work its way around a cycle, adding up the costs for each node, and then come across a node that was already reached by another path. 

In that case, a simple comparison is made between the two costs, and the node keeps the "cheapest" or smallest of the two costs. This guarantees that the shortest path between the source node and any other node is preserved.

In the end, this algorithm has a run time of $O(E log V)$, or the number of edges $E$ multiplied by the natural log of the vertices $V$

It is important to note that this algorithm will \emph{not} work with negative weights on the edges. The negative weight will be continually added to the cost of a node, and skew the node's actual weight.


\section{Bellman-Ford}

Bellman-Ford follows an overall similar process as Dijkstra's Algorithm, with one key change: Instead of running through the adjacent nodes, the algorithm loops through the list of edges V times (V being the number of vertices). 

In this algorithm, each node starts off with a weight of $\inf$. While looping through the list of edges, it updates the costs of the nodes adjacent to each edge, adding the weight both ways. In other words, it takes two nodes, and adds one node's cost to the edge's weight, and compares that sum to the cost of the other node. If the sum is less than the current cost, then the cost for the second node is updated. Doing this both ways between the two nodes ensures that the shortest path is maintained.

Below is an example of how this algorithm might work through a graph






Unlike Dijkstra's algorithm, the Bellman-Ford algorithm does work with negative weights, with a slight caveat. In order for the negative weights to not artificially skew the cost of a vertex, the weight cannot be a part of a cycle. If it is, however, the algorithm can catch the existence of this negative weight at the end. That is because of the algorithm running $V$ times. If there is not a negative cycle, it will take at most $V-1$ times for the algorithm to compute the correct cost for each vertex. After the $V$ iterations, if there is still a chance to update a vertex's cost, then there must be a negative cycle.